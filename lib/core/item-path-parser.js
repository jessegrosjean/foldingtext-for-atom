// Copyright (c) 2015 Jesse Grosjean. All rights reserved.

module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleIndices = { ItemPathExpression: 0, Value: 31 },
        peg$startRuleIndex   = 0,

        peg$consts = [
          peg$FAILED,
          function(paths) {
              paths.keywords = keywords;
              return paths;
            },
          function(left, right) { return combine(left, right, 'union') },
          "union",
          { type: "literal", value: "union", description: "\"union\"" },
          function(union) {
              keyword('keyword.set');
              return union;
            },
          function(left, right) { return combine(left, right, 'except') },
          "except",
          { type: "literal", value: "except", description: "\"except\"" },
          function(except) {
              keyword('keyword.set');
              return except;
            },
          function(left, right) { return combine(left, right, 'intersect') },
          "intersect",
          { type: "literal", value: "intersect", description: "\"intersect\"" },
          function(intersect) {
              keyword('keyword.set');
              return intersect;
            },
          "[",
          { type: "literal", value: "[", description: "\"[\"" },
          null,
          "]",
          { type: "literal", value: "]", description: "\"]\"" },
          function(start, end) {
              return {
                start: start === null ? 0 : start,
                end: end
              }
            },
          ":",
          { type: "literal", value: ":", description: "\":\"" },
          function(integer) {
              if (integer !== null) {
                return integer;
              }
              return Number.MAX_VALUE;
            },
          "-",
          { type: "literal", value: "-", description: "\"-\"" },
          [],
          /^[0-9]/,
          { type: "class", value: "[0-9]", description: "[0-9]" },
          function(sign, number) {
              if (sign) {
                return -parseInt(number.join(''), 10);
              } else {
                return parseInt(number.join(''), 10);
              }
            },
          void 0,
          "(",
          { type: "literal", value: "(", description: "\"(\"" },
          ")",
          { type: "literal", value: ")", description: "\")\"" },
          function(expression, slice) {
              expression.slice = slice;
              return expression;
            },
          "/",
          { type: "literal", value: "/", description: "\"/\"" },
          function(absolute, step, trailingSteps) {
              absolute = !! absolute;

              if (absolute) {
                keyword('entity.other.axis', offset(), '/');
              } else if (step.axis === 'child') {
                // Default to descendent axis for non absolute paths.
                step.axis = 'descendant';
              }

              var steps = [step];
              if (trailingSteps) {
                 steps = steps.concat(trailingSteps);
              }
              return {
                absolute : absolute,
                steps : steps
              }
            },
          function(axis, type, predicate, slice) {
              return type || predicate;
            },
          function(axis, type, predicate, slice) {
              if (!axis) {
                axis = 'child';
              }

              if (!type) {
                type = '*';
              }

              if (!predicate) {
                predicate = '*'
              }

              return {
                axis : axis,
                type : type,
                predicate : predicate,
                slice: slice
              }
            },
          "ancestor-or-self::",
          { type: "literal", value: "ancestor-or-self::", description: "\"ancestor-or-self::\"" },
          "ancestor::",
          { type: "literal", value: "ancestor::", description: "\"ancestor::\"" },
          "child::",
          { type: "literal", value: "child::", description: "\"child::\"" },
          "descendant-or-self::",
          { type: "literal", value: "descendant-or-self::", description: "\"descendant-or-self::\"" },
          "descendant::",
          { type: "literal", value: "descendant::", description: "\"descendant::\"" },
          "following-sibling::",
          { type: "literal", value: "following-sibling::", description: "\"following-sibling::\"" },
          "following::",
          { type: "literal", value: "following::", description: "\"following::\"" },
          "preceding-sibling::",
          { type: "literal", value: "preceding-sibling::", description: "\"preceding-sibling::\"" },
          "preceding::",
          { type: "literal", value: "preceding::", description: "\"preceding::\"" },
          "parent::",
          { type: "literal", value: "parent::", description: "\"parent::\"" },
          "self::",
          { type: "literal", value: "self::", description: "\"self::\"" },
          "..",
          { type: "literal", value: "..", description: "\"..\"" },
          function(axis) {
                keyword('entity.other.axis');

                switch(axis) {
                case '/':
                  return 'descendant';
                case '..':
                  return 'parent';
                default:
                  return axis.substr(0, axis.length - 2);
                }
              },
          function(name) {
              var types = options.types;
              return types && types[name];
            },
          function(name) {
              keyword('entity.other.axis');
              return name;
            },
          function(step) {
              keyword('entity.other.axis', offset(), '/');
              return step;
            },
          function(left, right) { return combine(left, right, 'or') },
          "or",
          { type: "literal", value: "or", description: "\"or\"" },
          function(or) {
              keyword('keyword.boolean');
              return or;
            },
          function(left, right) { return combine(left, right, 'and') },
          "and",
          { type: "literal", value: "and", description: "\"and\"" },
          function(and) {
              keyword('keyword.boolean');
              return and;
            },
          function(not, expression) {
              if (not && (not.length % 2)) {
                return {
                  not : expression
                };
              } else {
                return expression;
              }
            },
          "not",
          { type: "literal", value: "not", description: "\"not\"" },
          function(not) {
              keyword('keyword.boolean');
              return not;
            },
          function(expression) { return expression; },
          "*",
          { type: "literal", value: "*", description: "\"*\"" },
          "#",
          { type: "literal", value: "#", description: "\"#\"" },
          function(name) {
              var relation = null;
              var value = null;

              if (name) {
                relation = 'matches'
                value = '(^|,)' + name + '($|,)'
              }

              keyword('entity.other.tag');

              return {
                attributePath : ['data-tags'],
                relation : relation,
                value : value
              }
            },
          function(attributePath, relation, modifier, value) {
              return {
                attributePath : attributePath || ['text'],
                relation : relation || 'contains',
                modifier : modifier || 'i',
                value : value
              }
            },
          function(attributePath) {
              return {
                attributePath : attributePath,
                relation : null,
                value : null
              }
            },
          "@",
          { type: "literal", value: "@", description: "\"@\"" },
          function(name, trailingSegments) {
              var segments = [name];
              if (trailingSegments) {
                segments = segments.concat(trailingSegments);
              }
              keyword('entity.other.attribute-name');
              return segments;
            },
          function(name) { return name },
          function(startchar, chars) {
              return startchar + chars.join('');
            },
          function(char) { return char; },
          "beginswith",
          { type: "literal", value: "beginswith", description: "\"beginswith\"" },
          "contains",
          { type: "literal", value: "contains", description: "\"contains\"" },
          "endswith",
          { type: "literal", value: "endswith", description: "\"endswith\"" },
          "like",
          { type: "literal", value: "like", description: "\"like\"" },
          "matches",
          { type: "literal", value: "matches", description: "\"matches\"" },
          "=",
          { type: "literal", value: "=", description: "\"=\"" },
          "!=",
          { type: "literal", value: "!=", description: "\"!=\"" },
          "<=",
          { type: "literal", value: "<=", description: "\"<=\"" },
          ">=",
          { type: "literal", value: ">=", description: "\">=\"" },
          "<",
          { type: "literal", value: "<", description: "\"<\"" },
          ">",
          { type: "literal", value: ">", description: "\">\"" },
          function(relation) {
              keyword('keyword.operator.relation');
              return relation;
            },
          "s",
          { type: "literal", value: "s", description: "\"s\"" },
          "i",
          { type: "literal", value: "i", description: "\"i\"" },
          "n",
          { type: "literal", value: "n", description: "\"n\"" },
          "d",
          { type: "literal", value: "d", description: "\"d\"" },
          function(modifier) {
              keyword('keyword.operator.modifier');
              return modifier;
            },
          function(strings) {
              var results = [];
              for (var i = 0; i < strings.length; i++) {
                results.push(strings[i].join(''));
              }
              return results.join('').trim();
            },
          { type: "other", description: "string" },
          "\"",
          { type: "literal", value: "\"", description: "\"\\\"\"" },
          function() { return "";    },
          function(chars) {
              keyword('string.quoted');
              return chars;
            },
          function(chars) { return chars.join(""); },
          /^[^"\\\0-\x1F]/,
          { type: "class", value: "[^\"\\\\\\0-\\x1F]", description: "[^\"\\\\\\0-\\x1F]" },
          "\\\"",
          { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
          function() { return '"';  },
          "\\\\",
          { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
          function() { return "\\"; },
          "\\/",
          { type: "literal", value: "\\/", description: "\"\\\\/\"" },
          function() { return "/";  },
          "\\b",
          { type: "literal", value: "\\b", description: "\"\\\\b\"" },
          function() { return "\b"; },
          "\\f",
          { type: "literal", value: "\\f", description: "\"\\\\f\"" },
          function() { return "\f"; },
          "\\n",
          { type: "literal", value: "\\n", description: "\"\\\\n\"" },
          function() { return "\n"; },
          "\\r",
          { type: "literal", value: "\\r", description: "\"\\\\r\"" },
          function() { return "\r"; },
          "\\t",
          { type: "literal", value: "\\t", description: "\"\\\\t\"" },
          function() { return "\t"; },
          /^[.,]/,
          { type: "class", value: "[.,]", description: "[.,]" },
          function(string) {
              return reservedWords[string];
            },
          function(string) {
              keyword('string.unquoted');
              return string;
            },
          /^[A-Z]/,
          { type: "class", value: "[A-Z]", description: "[A-Z]" },
          "_",
          { type: "literal", value: "_", description: "\"_\"" },
          /^[a-z]/,
          { type: "class", value: "[a-z]", description: "[a-z]" },
          /^[\xC0-\xD6]/,
          { type: "class", value: "[\\xC0-\\xD6]", description: "[\\xC0-\\xD6]" },
          /^[\xD8-\xF6]/,
          { type: "class", value: "[\\xD8-\\xF6]", description: "[\\xD8-\\xF6]" },
          /^[\xF8-\u02FF]/,
          { type: "class", value: "[\\xF8-\\u02FF]", description: "[\\xF8-\\u02FF]" },
          /^[\u0370-\u037D]/,
          { type: "class", value: "[\\u0370-\\u037D]", description: "[\\u0370-\\u037D]" },
          /^[\u037F-\u1FFF]/,
          { type: "class", value: "[\\u037F-\\u1FFF]", description: "[\\u037F-\\u1FFF]" },
          /^[\u200C-\u200D]/,
          { type: "class", value: "[\\u200C-\\u200D]", description: "[\\u200C-\\u200D]" },
          /^[\u2070-\u218F]/,
          { type: "class", value: "[\\u2070-\\u218F]", description: "[\\u2070-\\u218F]" },
          /^[\u2C00-\u2FEF]/,
          { type: "class", value: "[\\u2C00-\\u2FEF]", description: "[\\u2C00-\\u2FEF]" },
          /^[\u3001-\uD7FF]/,
          { type: "class", value: "[\\u3001-\\uD7FF]", description: "[\\u3001-\\uD7FF]" },
          /^[\uF900-\uFDCF]/,
          { type: "class", value: "[\\uF900-\\uFDCF]", description: "[\\uF900-\\uFDCF]" },
          /^[\uFDF0-\uFFFD]/,
          { type: "class", value: "[\\uFDF0-\\uFFFD]", description: "[\\uFDF0-\\uFFFD]" },
          ".",
          { type: "literal", value: ".", description: "\".\"" },
          /^[\xB7]/,
          { type: "class", value: "[\\xB7]", description: "[\\xB7]" },
          /^[\u0300-\u036F]/,
          { type: "class", value: "[\\u0300-\\u036F]", description: "[\\u0300-\\u036F]" },
          /^[\u203F-\u2040]/,
          { type: "class", value: "[\\u203F-\\u2040]", description: "[\\u203F-\\u2040]" },
          { type: "other", description: "whitespace" },
          function(whitespace) { return whitespace.join("") },
          /^[ \t\n\r]/,
          { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }
        ],

        peg$bytecode = [
          peg$decode("!7!+2$7G+(%4\"6!\"!!%$\"#  \"#  "),
          peg$decode("!7#+Q$7G+G%7\"+=%7G+3%7!+)%4%6\"%\"$ %$%#  $$#  $##  $\"#  \"#  *# \"7#"),
          peg$decode("!.#\"\"2#3$+' 4!6%!! %"),
          peg$decode("!7%+Q$7G+G%7$+=%7G+3%7#+)%4%6&%\"$ %$%#  $$#  $##  $\"#  \"#  *# \"7%"),
          peg$decode("!.'\"\"2'3(+' 4!6)!! %"),
          peg$decode("!7*+Q$7G+G%7&+=%7G+3%7%+)%4%6*%\"$ %$%#  $$#  $##  $\"#  \"#  *# \"7*"),
          peg$decode("!.+\"\"2+3,+' 4!6-!! %"),
          peg$decode("!..\"\"2.3/+S$7)+I%7(*# \" 0+9%.1\"\"2132+)%4$63$\"\"!%$$#  $##  $\"#  \"#  "),
          peg$decode("!.4\"\"2435+8$7)*# \" 0+(%4\"66\"! %$\"#  \"#  "),
          peg$decode("!.7\"\"2738*# \" 0+N$ 90:\"\"1!3;+,$,)&0:\"\"1!3;\"\"\"  +)%4\"6<\"\"! %$\"#  \"#  "),
          peg$decode("!!8709*$$\"\" =\"#  +w$.>\"\"2>3?+g%7G+]%7!+S%7G+I%.@\"\"2@3A+9%7'*# \" 0+)%4'6B'\"# %$'#  $&#  $%#  $$#  $##  $\"#  \"#  *# \"7+"),
          peg$decode("!.C\"\"2C3D*# \" 0+F$7,+<% 97/,#&7/\"+*%4#6E##\"! %$##  $\"#  \"#  "),
          peg$decode("!7-*# \" 0+u$7.*# \" 0+e%70*# \" 0+U%7'*# \" 0+E%56F $#\"! )##\" =\"  ++%4%6G%$$#\"!%$%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!.H\"\"2H3I*\xAD \".J\"\"2J3K*\xA1 \".L\"\"2L3M*\x95 \".N\"\"2N3O*\x89 \".P\"\"2P3Q*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".X\"\"2X3Y*M \".Z\"\"2Z3[*A \".\\\"\"2\\3]*5 \".C\"\"2C3D*) \".^\"\"2^3_+' 4!6`!! %"),
          peg$decode("!7F+I$56a ! )##\" =\"  +2%7G+(%4#6b#!\"%$##  $\"#  \"#  "),
          peg$decode("!.C\"\"2C3D+2$7,+(%4\"6c\"! %$\"#  \"#  "),
          peg$decode("!72+Q$7G+G%71+=%7G+3%70+)%4%6d%\"$ %$%#  $$#  $##  $\"#  \"#  *# \"72"),
          peg$decode("!.e\"\"2e3f+' 4!6g!! %"),
          peg$decode("!74+Q$7G+G%73+=%7G+3%72+)%4%6h%\"$ %$%#  $$#  $##  $\"#  \"#  *# \"74"),
          peg$decode("!.i\"\"2i3j+' 4!6k!! %"),
          peg$decode("! 9!75+<$ 97H+&$,#&7H\"\"\"  +#%'\"%$\"#  \"#  ,G&!75+<$ 97H+&$,#&7H\"\"\"  +#%'\"%$\"#  \"#  \"+3$76+)%4\"6l\"\"! %$\"#  \"#  "),
          peg$decode("!.m\"\"2m3n+' 4!6o!! %"),
          peg$decode("!.>\"\"2>3?+V$7G+L%70+B%7G+8%.@\"\"2@3A+(%4%6p%!\"%$%#  $$#  $##  $\"#  \"#  *# \"77"),
          peg$decode(".q\"\"2q3r*\xC2 \"!.s\"\"2s3t+8$7F*# \" 0+(%4\"6u\"! %$\"#  \"#  *\x96 \"!78*# \" 0+s$7G+i%7=*# \" 0+Y%7G+O%7>*# \" 0+?%7G+5%7?++%4'6v'$&$\" %$'#  $&#  $%#  $$#  $##  $\"#  \"#  */ \"!78+' 4!6w!! %"),
          peg$decode("!.x\"\"2x3y+E$7:+;% 979,#&79\"+)%4#6z#\"! %$##  $\"#  \"#  "),
          peg$decode("!.4\"\"2435+2$7:+(%4\"6{\"! %$\"#  \"#  "),
          peg$decode("!7;+;$ 97<,#&7<\"+)%4\"6|\"\"! %$\"#  \"#  "),
          peg$decode("!!8.4\"\"24359*$$\"\" =\"#  +2$7D+(%4\"6}\"! %$\"#  \"#  "),
          peg$decode("!!8.4\"\"24359*$$\"\" =\"#  +2$7E+(%4\"6}\"! %$\"#  \"#  "),
          peg$decode("!.~\"\"2~3*\x95 \".\x80\"\"2\x803\x81*\x89 \".\x82\"\"2\x823\x83*} \".\x84\"\"2\x843\x85*q \".\x86\"\"2\x863\x87*e \".\x88\"\"2\x883\x89*Y \".\x8A\"\"2\x8A3\x8B*M \".\x8C\"\"2\x8C3\x8D*A \".\x8E\"\"2\x8E3\x8F*5 \".\x90\"\"2\x903\x91*) \".\x92\"\"2\x923\x93+' 4!6\x94!! %"),
          peg$decode("!..\"\"2.3/+l$.\x95\"\"2\x953\x96*A \".\x97\"\"2\x973\x98*5 \".\x99\"\"2\x993\x9A*) \".\x9B\"\"2\x9B3\x9C+8%.1\"\"2132+(%4#6\x9D#!!%$##  $\"#  \"#  "),
          peg$decode("! 9!7G+=$7@*# \"7C+-%7G+#%'#%$##  $\"#  \"#  +K$,H&!7G+=$7@*# \"7C+-%7G+#%'#%$##  $\"#  \"#  \"\"\"  +' 4!6\x9E!! %"),
          peg$decode("8!.\xA0\"\"2\xA03\xA1+A$.\xA0\"\"2\xA03\xA1+1%7G+'%4#6\xA2# %$##  $\"#  \"#  *S \"!.\xA0\"\"2\xA03\xA1+B$7A+8%.\xA0\"\"2\xA03\xA1+(%4#6\xA3#!!%$##  $\"#  \"#  9*\" 3\x9F"),
          peg$decode("! 97B+&$,#&7B\"\"\"  +' 4!6\xA4!! %"),
          peg$decode("0\xA5\"\"1!3\xA6*\xD5 \"!.\xA7\"\"2\xA73\xA8+& 4!6\xA9! %*\xBE \"!.\xAA\"\"2\xAA3\xAB+& 4!6\xAC! %*\xA7 \"!.\xAD\"\"2\xAD3\xAE+& 4!6\xAF! %*\x90 \"!.\xB0\"\"2\xB03\xB1+& 4!6\xB2! %*y \"!.\xB3\"\"2\xB33\xB4+& 4!6\xB5! %*b \"!.\xB6\"\"2\xB63\xB7+& 4!6\xB8! %*K \"!.\xB9\"\"2\xB93\xBA+& 4!6\xBB! %*4 \"!.\xBC\"\"2\xBC3\xBD+& 4!6\xBE! %"),
          peg$decode("8!0:\"\"1!3;*/ \"0\xBF\"\"1!3\xC0*# \"7F+?$56\xC1 ! )##\"  \" =+(%4\"6\xC2\"!!%$\"#  \"#  9*\" 3\x9F"),
          peg$decode(".4\"\"2435*\xC5 \"0\xC3\"\"1!3\xC4*\xB9 \".\xC5\"\"2\xC53\xC6*\xAD \"0\xC7\"\"1!3\xC8*\xA1 \"0\xC9\"\"1!3\xCA*\x95 \"0\xCB\"\"1!3\xCC*\x89 \"0\xCD\"\"1!3\xCE*} \"0\xCF\"\"1!3\xD0*q \"0\xD1\"\"1!3\xD2*e \"0\xD3\"\"1!3\xD4*Y \"0\xD5\"\"1!3\xD6*M \"0\xD7\"\"1!3\xD8*A \"0\xD9\"\"1!3\xDA*5 \"0\xDB\"\"1!3\xDC*) \"0\xDD\"\"1!3\xDE"),
          peg$decode("7D*e \".7\"\"2738*Y \".\xDF\"\"2\xDF3\xE0*M \"0:\"\"1!3;*A \"0\xE1\"\"1!3\xE2*5 \"0\xE3\"\"1!3\xE4*) \"0\xE5\"\"1!3\xE6"),
          peg$decode("!7D+;$ 97E,#&7E\"+)%4\"6|\"\"! %$\"#  \"#  "),
          peg$decode("8! 97H,#&7H\"+' 4!6\xE8!! %9*\" 3\xE7"),
          peg$decode("0\xE9\"\"1!3\xEA")
        ],

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$cache = {},
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$decode(s) {
      var bc = new Array(s.length), i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc    = peg$bytecode[index],
          ip    = 0,
          ips   = [],
          end   = bc.length,
          ends  = [],
          stack = [],
          params, i;

      var key    = peg$currPos * 41 + index,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      function protect(object) {
        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
      }

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(protect(peg$consts[bc[ip + 1]]));
              ip += 2;
              break;

            case 1:
              stack.push(peg$currPos);
              ip++;
              break;

            case 2:
              stack.pop();
              ip++;
              break;

            case 3:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 4:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 5:
              stack.splice(-2, 1);
              ip++;
              break;

            case 6:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 7:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 8:
              stack.pop();
              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
              ip++;
              break;

            case 9:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 10:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 11:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 12:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 16:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 17:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 18:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 19:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 20:
              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 21:
              peg$reportedPos = peg$currPos;
              ip++;
              break;

            case 22:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(
                stack.length - bc[ip + 2],
                bc[ip + 2],
                peg$consts[bc[ip + 1]].apply(null, params)
              );

              ip += 4 + bc[ip + 3];
              break;

            case 23:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 24:
              peg$silentFails++;
              ip++;
              break;

            case 25:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: stack[0] };

      return stack[0];
    }


      var reservedWords = {
        'union': true,
        'except': true,
        'intersect': true,
        'and': true,
        'or': true,
        'not': true
      }

      function combine(left, right, label) {
        if (right) {
          var result = {};
          result[label] = [left, right];
          return result;
        } else {
          return left;
        }
      }

      var keywords = [];

      function keywordCompare(a, b) {
        var aOffset = a.offset
        var bOffset = b.offset

        if (aOffset !== bOffset) {
          return aOffset - bOffset;
        } else if (a.text.length !== b.text.length) {
          return a.text.length - b.text.length;
        } else if (a.label !== b.label) {
          if (a < b) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return 0;
        }
      }

      function keyword(label, offsetValue, textValue) {
        offsetValue = offsetValue === undefined ? offset() : offsetValue;
        textValue = textValue === undefined ? text() : textValue;

        var length = keywords.length - 1;
        while (length >= 0 && keywords[length].offset === offsetValue) {
          keywords.pop();
          length--;
        }

        keywords.push({
          label: label,
          offset : offsetValue,
          text : textValue
        });

        keywords.sort(keywordCompare);
      }


    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();